names(links)[names(links) == 'urank1_major'] <- 'source'
names(links)[names(links) == 'urank2_major'] <- 'target'
links <- links %>%
group_by(source) %>%
mutate(prop1 = sum(prop))
links <- links %>%
group_by(target) %>%
mutate(prop2 = sum(prop))
links <- links[order(links$prop1,links$prop,decreasing=TRUE), ]
links <- links[links$prop1>0.04 & links$prop2 > 0.04, ]
names(links)[names(links) == 'N'] <- 'value'
#links$source <- paste("1.",links$source)
#links$target <- paste("2.",links$target)
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(
name=c(as.character(links$source),
as.character(links$target)) %>% unique()
)
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
links$IDsource <- match(links$source, nodes$name)-1
links$IDtarget <- match(links$target, nodes$name)-1
ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","#B4DE2CFF","#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'
# Make the Network
p <- sankeyNetwork(Links = links, Nodes = nodes,
Source = "IDsource", Target = "IDtarget",
Value = "value", NodeID = "name",
sinksRight=FALSE)
p
p <- sankeyNetwork(Links = links, Nodes = nodes,
Source = "IDsource", Target = "IDtarget",
Value = "value", NodeID = "name",
sinksRight=TRUE)
p
#clear memory
rm(list = ls())
# Load dataset
#links <- read.csv("/Users/mendi/Research/HJV_MajorChoice/output/exp_wage_rank_pairs.csv", header=TRUE)
#links <- read.csv("/Users/mendi/Research/HJV_MajorChoice/output/exp_pvdispinc_rank_pairs.csv", header=TRUE)
#names(links)[names(links) == 'wrank1_major'] <- 'source'
#names(links)[names(links) == 'wrank2_major'] <- 'target'
links <- read.csv("/Users/mendi/Research/HJV_MajorChoice/output/exp_utility_rank_pairs.csv", header=TRUE)
names(links)[names(links) == 'urank1_major'] <- 'source'
names(links)[names(links) == 'urank2_major'] <- 'target'
links <- links %>%
group_by(source) %>%
mutate(prop1 = sum(prop))
links <- links %>%
group_by(target) %>%
mutate(prop2 = sum(prop))
links <- links[order(links$prop1,links$prop,decreasing=TRUE), ]
links <- links[links$prop1>0.04 & links$prop2 > 0.04, ]
names(links)[names(links) == 'N'] <- 'value'
#links$source <- paste(links$source)
links$target <- paste(links$target,"")
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(
name=c(as.character(links$source),
as.character(links$target)) %>% unique()
)
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
links$IDsource <- match(links$source, nodes$name)-1
links$IDtarget <- match(links$target, nodes$name)-1
ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","#B4DE2CFF","#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'
# Make the Network
p <- sankeyNetwork(Links = links, Nodes = nodes,
Source = "IDsource", Target = "IDtarget",
Value = "value", NodeID = "name",
sinksRight=FALSE)
p
View(links)
View(links)
# Libraries
library(pacman)
p_load(networkD3,dplyr)
#clear memory
rm(list = ls())
# Load dataset
#links <- read.csv("/Users/mendi/Research/HJV_MajorChoice/output/exp_wage_rank_pairs.csv", header=TRUE)
#links <- read.csv("/Users/mendi/Research/HJV_MajorChoice/output/exp_pvdispinc_rank_pairs.csv", header=TRUE)
#names(links)[names(links) == 'wrank1_major'] <- 'source'
#names(links)[names(links) == 'wrank2_major'] <- 'target'
links <- read.csv("/Users/mendi/Research/HJV_MajorChoice/output/exp_utility_rank_pairs.csv", header=TRUE)
names(links)[names(links) == 'urank1_major'] <- 'source'
names(links)[names(links) == 'urank2_major'] <- 'target'
links[target==""]$target <- "Do not enroll"
links[links$target==""]$target <- "Do not enroll"
links[links$target=='']$target <- "Do not enroll"
count(is.na(links.target))
count(is.na(links$target))
sum(is.na(links$target))
max(is.na(links$target))
sum(links$target=="")
links[links$target==""]$target <- "Do not enroll"
links[links$target=="",]$target <- "Do not enroll"
library(pacman)
p_load(networkD3,dplyr)
#clear memory
rm(list = ls())
# Load dataset
#links <- read.csv("/Users/mendi/Research/HJV_MajorChoice/output/exp_wage_rank_pairs.csv", header=TRUE)
#links <- read.csv("/Users/mendi/Research/HJV_MajorChoice/output/exp_pvdispinc_rank_pairs.csv", header=TRUE)
#names(links)[names(links) == 'wrank1_major'] <- 'source'
#names(links)[names(links) == 'wrank2_major'] <- 'target'
links <- read.csv("/Users/mendi/Research/HJV_MajorChoice/output/exp_utility_rank_pairs.csv", header=TRUE)
names(links)[names(links) == 'urank1_major'] <- 'source'
names(links)[names(links) == 'urank2_major'] <- 'target'
links[links$target=="",]$target <- "Do not enroll"
links <- links %>%
group_by(source) %>%
mutate(prop1 = sum(prop))
links <- links %>%
group_by(target) %>%
mutate(prop2 = sum(prop))
links <- links[order(links$prop1,links$prop,decreasing=TRUE), ]
links <- links[links$prop1>0.04 & links$prop2 > 0.04, ]
names(links)[names(links) == 'N'] <- 'value'
#links$source <- paste(links$source)
links$target <- paste(links$target,"")
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(
name=c(as.character(links$source),
as.character(links$target)) %>% unique()
)
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
links$IDsource <- match(links$source, nodes$name)-1
links$IDtarget <- match(links$target, nodes$name)-1
ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","#B4DE2CFF","#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'
# Make the Network
p <- sankeyNetwork(Links = links, Nodes = nodes,
Source = "IDsource", Target = "IDtarget",
Value = "value", NodeID = "name",
sinksRight=FALSE)
p
library(pacman)
p_load(networkD3,dplyr)
#clear memory
rm(list = ls())
# Load dataset
#links <- read.csv("/Users/mendi/Research/HJV_MajorChoice/output/exp_wage_rank_pairs.csv", header=TRUE)
#links <- read.csv("/Users/mendi/Research/HJV_MajorChoice/output/exp_pvdispinc_rank_pairs.csv", header=TRUE)
#names(links)[names(links) == 'wrank1_major'] <- 'source'
#names(links)[names(links) == 'wrank2_major'] <- 'target'
links <- read.csv("/Users/mendi/Research/HJV_MajorChoice/output/exp_utility_rank_pairs.csv", header=TRUE)
names(links)[names(links) == 'urank1_major'] <- 'source'
names(links)[names(links) == 'urank2_major'] <- 'target'
links[links$target=="",]$target <- "Do not enroll"
links <- links %>%
group_by(source) %>%
mutate(prop1 = sum(prop))
links <- links %>%
group_by(target) %>%
mutate(prop2 = sum(prop))
links <- links[order(links$prop1,links$prop,decreasing=TRUE), ]
library(pacman)
p_load(networkD3,dplyr)
#clear memory
rm(list = ls())
# Load dataset
#links <- read.csv("/Users/mendi/Research/HJV_MajorChoice/output/exp_wage_rank_pairs.csv", header=TRUE)
#links <- read.csv("/Users/mendi/Research/HJV_MajorChoice/output/exp_pvdispinc_rank_pairs.csv", header=TRUE)
#names(links)[names(links) == 'wrank1_major'] <- 'source'
#names(links)[names(links) == 'wrank2_major'] <- 'target'
links <- read.csv("/Users/mendi/Research/HJV_MajorChoice/output/exp_utility_rank_pairs.csv", header=TRUE)
names(links)[names(links) == 'urank1_major'] <- 'source'
names(links)[names(links) == 'urank2_major'] <- 'target'
links[links$target=="",]$target <- "Do not enroll"
links <- links %>%
group_by(source) %>%
mutate(prop1 = sum(prop))
links <- links %>%
group_by(target) %>%
mutate(prop2 = sum(prop))
links <- links[order(links$prop1,links$prop,decreasing=TRUE), ]
links <- links[links$prop1>0.005 & links$prop2 > 0.005, ]
names(links)[names(links) == 'N'] <- 'value'
#links$source <- paste(links$source)
links$target <- paste(links$target,"")
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(
name=c(as.character(links$source),
as.character(links$target)) %>% unique()
)
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
links$IDsource <- match(links$source, nodes$name)-1
links$IDtarget <- match(links$target, nodes$name)-1
ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","#B4DE2CFF","#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'
# Make the Network
p <- sankeyNetwork(Links = links, Nodes = nodes,
Source = "IDsource", Target = "IDtarget",
Value = "value", NodeID = "name",
sinksRight=FALSE)
p
# Libraries
library(pacman)
p_load(networkD3,dplyr)
#clear memory
rm(list = ls())
# Load dataset
#links <- read.csv("/Users/mendi/Research/HJV_MajorChoice/output/exp_wage_rank_pairs.csv", header=TRUE)
#links <- read.csv("/Users/mendi/Research/HJV_MajorChoice/output/exp_pvdispinc_rank_pairs.csv", header=TRUE)
#names(links)[names(links) == 'wrank1_major'] <- 'source'
#names(links)[names(links) == 'wrank2_major'] <- 'target'
links <- read.csv("/Users/mendi/Research/HJV_MajorChoice/output/exp_utility_rank_pairs.csv", header=TRUE)
names(links)[names(links) == 'urank1_major'] <- 'source'
names(links)[names(links) == 'urank2_major'] <- 'target'
links[links$target=="",]$target <- "Do not enroll"
links <- links %>%
group_by(source) %>%
mutate(prop1 = sum(prop))
links <- links %>%
group_by(target) %>%
mutate(prop2 = sum(prop))
links <- links[order(links$prop1,links$prop,decreasing=TRUE), ]
#links <- links[links$prop1>0.005 & links$prop2 > 0.005, ]
names(links)[names(links) == 'N'] <- 'value'
#links$source <- paste(links$source)
links$target <- paste(links$target,"")
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(
name=c(as.character(links$source),
as.character(links$target)) %>% unique()
)
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
links$IDsource <- match(links$source, nodes$name)-1
links$IDtarget <- match(links$target, nodes$name)-1
ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","#B4DE2CFF","#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'
# Make the Network
p <- sankeyNetwork(Links = links, Nodes = nodes,
Source = "IDsource", Target = "IDtarget",
Value = "value", NodeID = "name",
sinksRight=FALSE)
p
source("~/Dropbox (Personal)/Greg/Work/Research/HJV_MajorChoice/output/SankeyRankings/Sankey.R", echo=TRUE)
source("~/Dropbox (Personal)/Greg/Work/Research/HJV_MajorChoice/output/SankeyRankings/Sankey.R", echo=TRUE)
source("~/Dropbox (Personal)/Greg/Work/Research/HJV_MajorChoice/output/SankeyRankings/Sankey.R", echo=TRUE)
# Libraries
library(pacman)
p_load(networkD3,dplyr)
#clear memory
rm(list = ls())
##########################
#Use wage and PV DispInc rankings
links <- read.csv("/Users/mendi/Research/HJV_MajorChoice/output/exp_wage_rank_pairs.csv", header=TRUE)
#links <- read.csv("/Users/mendi/Research/HJV_MajorChoice/output/exp_pvdispinc_rank_pairs.csv", header=TRUE)
names(links)[names(links) == 'wrank1_major'] <- 'source'
names(links)[names(links) == 'wrank2_major'] <- 'target'
links <- links %>%
group_by(source) %>%
mutate(prop1 = sum(prop))
links <- links %>%
group_by(target) %>%
mutate(prop2 = sum(prop))
links <- links[order(links$prop1,links$prop,decreasing=TRUE), ]
#links <- links[links$prop1>0.04 & links$prop2 > 0.04, ]
names(links)[names(links) == 'N'] <- 'value'
#links$source <- paste(links$source)
links$target <- paste(links$target,"")
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(
name=c(as.character(links$source),
as.character(links$target)) %>% unique()
)
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
links$IDsource <- match(links$source, nodes$name)-1
links$IDtarget <- match(links$target, nodes$name)-1
ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","#B4DE2CFF","#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'
# Make the Network
p <- sankeyNetwork(Links = links, Nodes = nodes,
Source = "IDsource", Target = "IDtarget",
Value = "value", NodeID = "name",
sinksRight=FALSE)
p
# Libraries
library(pacman)
p_load(networkD3,dplyr)
#clear memory
rm(list = ls())
##########################
#Use wage and PV DispInc rankings
links <- read.csv("/Users/mendi/Research/HJV_MajorChoice/output/exp_wage_rank_pairs.csv", header=TRUE)
#links <- read.csv("/Users/mendi/Research/HJV_MajorChoice/output/exp_pvdispinc_rank_pairs.csv", header=TRUE)
names(links)[names(links) == 'wrank1_major'] <- 'source'
names(links)[names(links) == 'wrank2_major'] <- 'target'
##########################
#Use utility rankings
#links <- read.csv("/Users/mendi/Research/HJV_MajorChoice/output/exp_utility_rank_pairs.csv", header=TRUE)
#names(links)[names(links) == 'urank1_major'] <- 'source'
#names(links)[names(links) == 'urank2_major'] <- 'target'
#links[links$target=="",]$target <- "Do not enroll"
####
links <- links %>%
group_by(source) %>%
mutate(prop1 = sum(prop))
links <- links %>%
group_by(target) %>%
mutate(prop2 = sum(prop))
links <- links[order(links$prop1,links$prop,decreasing=TRUE), ]
links <- links[links$prop1>0.04 & links$prop2 > 0.04, ]
names(links)[names(links) == 'N'] <- 'value'
#links$source <- paste(links$source)
links$target <- paste(links$target,"")
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(
name=c(as.character(links$source),
as.character(links$target)) %>% unique()
)
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
links$IDsource <- match(links$source, nodes$name)-1
links$IDtarget <- match(links$target, nodes$name)-1
ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","#B4DE2CFF","#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'
# Make the Network
p <- sankeyNetwork(Links = links, Nodes = nodes,
Source = "IDsource", Target = "IDtarget",
Value = "value", NodeID = "name",
sinksRight=FALSE)
p
source("~/Dropbox (Personal)/Greg/Work/Research/HJV_MajorChoice/output/SankeyRankings/Sankey.R", echo=TRUE)
# Libraries
library(pacman)
p_load(networkD3,dplyr)
#clear memory
rm(list = ls())
source("~/Dropbox (Personal)/Greg/Work/Research/HJV_MajorChoice/output/SankeyRankings/Sankey.R", echo=TRUE)
# Libraries
library(pacman)
p_load(networkD3,dplyr)
#clear memory
rm(list = ls())
##########################
#Use wage and PV DispInc rankings
#links <- read.csv("/Users/mendi/Research/HJV_MajorChoice/output/exp_wage_rank_pairs.csv", header=TRUE)
#names(links)[names(links) == 'wrank1_major'] <- 'source'
#names(links)[names(links) == 'wrank2_major'] <- 'target'
links <- read.csv("/Users/mendi/Research/HJV_MajorChoice/output/exp_pvdispinc_rank_pairs.csv", header=TRUE)
names(links)[names(links) == 'pvrank1_major'] <- 'source'
names(links)[names(links) == 'pvrank2_major'] <- 'target'
##########################
#Use utility rankings
#links <- read.csv("/Users/mendi/Research/HJV_MajorChoice/output/exp_utility_rank_pairs.csv", header=TRUE)
#names(links)[names(links) == 'urank1_major'] <- 'source'
#names(links)[names(links) == 'urank2_major'] <- 'target'
#links[links$target=="",]$target <- "Do not enroll"
####
links <- links %>%
group_by(source) %>%
mutate(prop1 = sum(prop))
links <- links %>%
group_by(target) %>%
mutate(prop2 = sum(prop))
links <- links[order(links$prop1,links$prop,decreasing=TRUE), ]
links <- links[links$prop1>0.04 & links$prop2 > 0.04, ]
names(links)[names(links) == 'N'] <- 'value'
#links$source <- paste(links$source)
links$target <- paste(links$target,"")
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(
name=c(as.character(links$source),
as.character(links$target)) %>% unique()
)
# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
links$IDsource <- match(links$source, nodes$name)-1
links$IDtarget <- match(links$target, nodes$name)-1
ColourScal ='d3.scaleOrdinal() .range(["#FDE725FF","#B4DE2CFF","#6DCD59FF","#35B779FF","#1F9E89FF","#26828EFF","#31688EFF","#3E4A89FF","#482878FF","#440154FF"])'
# Make the Network
p <- sankeyNetwork(Links = links, Nodes = nodes,
Source = "IDsource", Target = "IDtarget",
Value = "value", NodeID = "name",
sinksRight=FALSE)
p
library(pacman)
p_load(dplyr, magrittr, ineq, plm, haven,estimatr,AER)
p_load(devtools)
devtools::install_github("https://github.com/rgiordan/zaminfluence/",
ref="master",
subdir="zaminfluence",
force=TRUE)
library(pacman)
p_load(dplyr, magrittr, ineq, plm, haven,estimatr,AER)
p_load(devtools)
devtools::install_github("https://github.com/rgiordan/zaminfluence/",
ref="master",
subdir="zaminfluence",
force=TRUE)
rm(list = ls())
library(tidyverse)
rm(list = ls())
library(pacman)
p_load(dplyr, magrittr, ineq, plm, haven,estimatr,AER)
p_load(tidyverse,gridExtra,zaminfluence,AER)
rm(list = ls())
library(pacman)
p_load(dplyr, magrittr, ineq, plm, haven,estimatr,AER)
p_load(tidyverse,gridExtra,zaminfluence,AER)
compare <- function(x, y) { return(max(abs(x - y))) }
check_equivalent  <- function(x, y) { stopifnot(compare(x, y) < 1e-8) }
num_obs <- 20200
set.seed(42)
# Generate data.
set.seed(42)
x_dim <- 2
param <- -.07
T <- c(rep(1, 200), rep(0, 20000))
error <- rnorm(num_obs, mean = 0, sd = .1)
y=0-param*T+error
simulated_data <- data.frame(T = T, y = y, error=error)
reg_form <- formula("y ~ T + 1")
fit_object <- lm(data = simulated_data, formula=reg_form, x=TRUE, y=TRUE)
# Get influence and reruns.
model_grads <-
ComputeModelInfluence(fit_object, keep_pars=c("T")) %>%
AppendTargetRegressorInfluence("T")
signals <- GetInferenceSignals(model_grads)
signals %>% names()
signals[["T"]] %>% names()
signal <- signals[["T"]][["sign"]]
signal$apip
reruns <- RerunForSignals(signals, model_grads)
preds <- PredictForSignals(signals, model_grads)
IAPT_waiting_times <- readRDS("~/Downloads/IAPT_waiting_times.rds")
names(IAPT_waiting_times)
table(qperiod)
table(IAPT_waiting_times$qperiod)
load("/Users/mendi/Dropbox (Personal)/Greg/Work/Teaching/2025/EC2209/Seminar/S9/NED_data.RData")
rename(NED_data, exam4 = examgrade4)
library(tidyverse)
rename(NED_data, exam4 = examgrade4)
NED_data <- rename(NED_data, exam4 = examgrade4)
NED_data <- rename(NED_data, exam5 = examgrade5)
save(NED_data,"/Users/mendi/Dropbox (Personal)/Greg/Work/Teaching/2025/EC2209/Seminar/S9/NED_data.RData")
?save()
save(NED_data,file="/Users/mendi/Dropbox (Personal)/Greg/Work/Teaching/2025/EC2209/Seminar/S9/NED_data.RData")
install.packages("parallelly")
library(parallelly)
supportsMulticore()
?lapply
install.packages(c("foreach", "doParallel"))
library(foreach)
library(doParallel)
# How many cores does your CPU have
n_cores <- detectCores()
n_cores
# Register clustercluster <- makeCluster(4)registerDoParallel(cluster)# How many times will the loop runn_iterations <- 1000# To save the resultsresults <- list()# Use foreach and %dopar% to run the loop in parallelresults <- foreach(i = 1:n_iterations) %dopar% { # Store the results results[i] <- i^2}# Don't fotget to stop the clusterstopCluster(cl = cluster)
cluster <- makeCluster(4)
registerDoParallel(cluster)
n_iterations <- 1000
results <- list()
# Use foreach and %dopar% to run the loop in parallel
results <- foreach(i = 1:n_iterations) %dopar% {
# Store the results
results[i] <- i^2
}
# Don't forget to stop the cluster
stopCluster(cl = cluster)
source("~/.active-rstudio-document", echo = TRUE)
stopCluster(cl = cluster)
source("~/.active-rstudio-document", echo = TRUE)
source("~/.active-rstudio-document", echo = TRUE)
source("~/.active-rstudio-document", echo = TRUE)
source("~/.active-rstudio-document", echo = TRUE)
source("~/.active-rstudio-document", echo = TRUE)
source("~/.active-rstudio-document", echo = TRUE)
Sys.sleep(10)
16*10
16*10/60
source("~/parallel.R", echo = TRUE)
di 80+160+20+40+11+21
80+160+20+40+11+21
(80+160+20+40+11+21)/60
print(paste("Your computer has", n_core, "cores."))
print(paste("Your computer has", n_cores, "cores."))
source("~/parallel.R", echo = TRUE)
source("~/parallel.R", echo = TRUE)
source("~/parallel_pi_test.r", echo = TRUE)
source("~/parallel_pi_test.r", echo = TRUE)
source("~/parallel_pi_test.r", echo = TRUE)
source("~/parallel_pi_test.r", echo = TRUE)
source("~/parallel_pi_test.r", echo = TRUE)
install.package("ipoptr")
cd /Users/mendi/Dropbox\ \(Personal\)/Greg/Work/Research/Project-code/factorana/factorana_R_interface
cd "/Users/mendi/Dropbox\ \(Personal\)/Greg/Work/Research/Project-code/factorana/factorana_R_interface"
source("~/.active-rstudio-document", echo = TRUE)
cd "~/Research/Project-code/factorana/factorana_R_interface"
cd ~
/
setwd("~/Research/Project-code/factorana/factorana_R_interface")
library(testthat)
library(factorana)
Sys.setenv(FACTORANA_TEST_VERBOSE='TRUE')
Sys.setenv(NOT_CRAN='true')
test_file('tests/testthat/test-parallelization.R')
library(testthat)
library(factorana)
Sys.setenv(FACTORANA_TEST_VERBOSE='TRUE')
Sys.setenv(NOT_CRAN='true')
test_file('tests/testthat/test-parallelization.R')
setwd("~/Research/Project-code/factorana/factorana_R_interface")
rm(list = ls())
library(testthat)
library(factorana)
Sys.setenv(FACTORANA_TEST_VERBOSE='TRUE')
Sys.setenv(NOT_CRAN='true')
test_file('tests/testthat/test-parallelization.R')
setwd("~/Research/Project-code/factorana/factorana_R_interface")
rm(list = ls())
library(testthat)
library(factorana)
Sys.setenv(FACTORANA_TEST_VERBOSE='TRUE')
Sys.setenv(NOT_CRAN='true')
test_file('tests/testthat/test-parallelization.R')
library(factorana)
R CMD build
CMD build
